# CS50x Lecture 0: Scratch - Complete Study Notes

## üéØ Overview
This lecture introduces computer science fundamentals through problem-solving, representation systems, and visual programming with Scratch.

---

## 1. What is Computer Science? üß†

### Core Definition
**Computer Science** = The art of solving problems **computationally**

### Key Components:
- **Input**: The problem/data you start with
- **Algorithm**: Step-by-step instructions to solve the problem  
- **Output**: The solution/result

### Real-World Example:
Finding someone in a phone book:
- **Input**: Phone book + person's name
- **Algorithm**: 
  1. Open to middle page
  2. If name is on this page ‚Üí Done!
  3. If name comes before this page ‚Üí Search left half
  4. If name comes after this page ‚Üí Search right half
  5. Repeat until found
- **Output**: Person's phone number

### Why This Matters:
Problem-solving skills transfer everywhere - cooking, planning trips, organizing data, building apps.

---

## 2. Number Systems üî¢

### Unary System (Base 1)
- **How it works**: Count by adding one mark each time
- **Example**: |||| represents 4
- **Problem**: Extremely inefficient for large numbers

### Decimal System (Base 10) 
- **How it works**: Uses digits 0-9
- **Place values**: Each position represents powers of 10
- **Example**: 123 = (1√ó10¬≤) + (2√ó10¬π) + (3√ó10‚Å∞)

### Binary System (Base 2)
- **How it works**: Uses only 0 and 1
- **Place values**: Each position represents powers of 2
- **Example**: 101‚ÇÇ = (1√ó2¬≤) + (0√ó2¬π) + (1√ó2‚Å∞) = 4 + 0 + 1 = 5‚ÇÅ‚ÇÄ

### Binary Counting Table:
| Decimal | Binary | Calculation |
|---------|--------|-------------|
| 0 | 000 | 0√ó4 + 0√ó2 + 0√ó1 |
| 1 | 001 | 0√ó4 + 0√ó2 + 1√ó1 |
| 2 | 010 | 0√ó4 + 1√ó2 + 0√ó1 |
| 3 | 011 | 0√ó4 + 1√ó2 + 1√ó1 |
| 4 | 100 | 1√ó4 + 0√ó2 + 0√ó1 |
| 5 | 101 | 1√ó4 + 0√ó2 + 1√ó1 |
| 6 | 110 | 1√ó4 + 1√ó2 + 0√ó1 |
| 7 | 111 | 1√ó4 + 1√ó2 + 1√ó1 |

---

## 3. Bits and Bytes üíæ

### Bits
- **Definition**: Smallest unit of information in computing
- **Values**: 0 or 1 (off or on)
- **Physical representation**: Transistors in computer chips

### Bytes
- **Definition**: 8 bits grouped together
- **Storage capacity**: Can represent 2‚Å∏ = 256 different values (0-255)
- **Why 8 bits?**: Standardized size that can represent all ASCII characters

### Storage Hierarchy:
- 1 Bit = 0 or 1
- 1 Byte = 8 bits
- 1 Kilobyte (KB) = 1,024 bytes
- 1 Megabyte (MB) = 1,024 KB
- 1 Gigabyte (GB) = 1,024 MB
- 1 Terabyte (TB) = 1,024 GB

---

## 4. Decimal to Binary Conversion üîÑ

### Method 1: Division by 2
**Steps**:
1. Divide number by 2
2. Write down remainder (0 or 1)
3. Use quotient for next division
4. Repeat until quotient is 0
5. Read remainders from bottom to top

**Example**: Convert 13 to binary
- 13 √∑ 2 = 6 remainder 1
- 6 √∑ 2 = 3 remainder 0  
- 3 √∑ 2 = 1 remainder 1
- 1 √∑ 2 = 0 remainder 1
- **Result**: 1101‚ÇÇ

### Method 2: Powers of 2
**Steps**:
1. Find largest power of 2 ‚â§ your number
2. Subtract it, place 1 in that position
3. Repeat with remainder
4. Fill empty positions with 0

**Example**: Convert 13 to binary
- 13 - 8(2¬≥) = 5 ‚Üí place 1 in 2¬≥ position
- 5 - 4(2¬≤) = 1 ‚Üí place 1 in 2¬≤ position  
- 1 - 1(2‚Å∞) = 0 ‚Üí place 1 in 2‚Å∞ position
- **Result**: 1101‚ÇÇ (positions: 2¬≥ 2¬≤ 2¬π 2‚Å∞)

---

## 5. Text Representation: ASCII & Unicode üìù

### ASCII (American Standard Code for Information Interchange)
- **Purpose**: Standard way to represent text characters as numbers
- **Range**: 0-127 (fits in 7 bits, stored in 8 bits)
- **Coverage**: English letters, numbers, punctuation, control characters

### Key ASCII Values:
| Character | ASCII Value | Binary |
|-----------|-------------|---------|
| A | 65 | 1000001 |
| B | 66 | 1000010 |
| a | 97 | 1100001 |
| 0 | 48 | 0110000 |
| Space | 32 | 0100000 |

### ASCII Pattern Recognition:
- **Capital letters**: A(65) to Z(90)
- **Lowercase letters**: a(97) to z(122)  
- **Digits**: 0(48) to 9(57)
- **Difference**: Lowercase = Uppercase + 32

### Unicode
- **Purpose**: Represent ALL world languages and symbols
- **Range**: Over 1 million possible characters
- **Encoding**: UTF-8, UTF-16, UTF-32
- **Backward compatibility**: First 128 characters match ASCII exactly

---

## 6. Emojis and Colors üé®

### Emojis
- **Technical representation**: Unicode characters
- **Example**: üòÄ = U+1F600 (Unicode code point)
- **Skin tone modifiers**: Additional Unicode characters
- **Platform differences**: Each OS renders emojis differently

### Color Representation: RGB
- **RGB Model**: Red, Green, Blue components
- **Range**: Each component from 0-255 (8 bits each)
- **Total colors**: 256¬≥ = 16,777,216 possible colors
- **Storage**: 24 bits (3 bytes) per pixel

### RGB Examples:
| Color | Red | Green | Blue | Hex Code |
|-------|-----|-------|------|----------|
| Black | 0 | 0 | 0 | #000000 |
| White | 255 | 255 | 255 | #FFFFFF |
| Red | 255 | 0 | 0 | #FF0000 |
| Green | 0 | 255 | 0 | #00FF00 |
| Blue | 0 | 0 | 255 | #0000FF |

---

## 7. Sound and Video Representation üéµüé¨

### Digital Sound
- **Analog to Digital**: Sample sound waves at regular intervals
- **Sample Rate**: How often we measure (e.g., 44,100 Hz for CDs)
- **Bit Depth**: How precisely we measure each sample
- **File Size**: Sample Rate √ó Bit Depth √ó Time √ó Channels

### Digital Video
- **Concept**: Series of still images (frames) shown rapidly
- **Frame Rate**: Frames per second (FPS) - usually 24, 30, or 60
- **Resolution**: Width √ó Height in pixels
- **File Size**: Frame Rate √ó Resolution √ó Color Depth √ó Time

---

## 8. Algorithms üìã

### Definition
**Algorithm**: Step-by-step instructions to solve a problem

### Essential Properties:
1. **Input**: What goes in
2. **Output**: What comes out  
3. **Definiteness**: Each step clearly defined
4. **Finiteness**: Must eventually terminate
5. **Effectiveness**: Each step must be doable

### Algorithm Efficiency
Measured by how performance changes as input size grows:

| Algorithm | Time Complexity | Example |
|-----------|-----------------|---------|
| Linear Search | O(n) | Check each item one by one |
| Binary Search | O(log n) | Divide and conquer approach |
| Selection Sort | O(n¬≤) | Find minimum, swap, repeat |

### Real Algorithm Example: Making Tea
1. **Input**: Tea bag, hot water, cup, sugar (optional)
2. **Steps**:
   - Put tea bag in cup
   - Pour hot water over tea bag
   - Wait 3-5 minutes
   - Remove tea bag
   - Add sugar if desired
   - Stir
3. **Output**: Cup of tea

---

## 9. Pseudocode üìù

### Purpose
Write algorithms in structured English before coding

### Benefits:
- Focus on logic, not syntax
- Language-independent  
- Easy to understand and modify
- Bridge between problem and code

### Pseudocode Example: Find Maximum Number
```
INPUT: list of numbers
SET max = first number in list
FOR each remaining number in list:
    IF current number > max:
        SET max = current number
OUTPUT: max
```

### Common Pseudocode Elements:
- **Variables**: `SET variable = value`
- **Input/Output**: `INPUT user_name` / `OUTPUT result`
- **Conditions**: `IF condition THEN ... ELSE ...`
- **Loops**: `WHILE condition` / `FOR each item`
- **Functions**: `FUNCTION name(parameters)`

---

## 10. Artificial Intelligence & ChatGPTs ü§ñ

### What is AI?
- **Broad Definition**: Machines performing tasks that typically require human intelligence
- **Current AI**: Pattern recognition and response generation based on training data

### Large Language Models (LLMs)
- **Training**: Fed massive amounts of text from the internet
- **Learning**: Identify patterns in language and knowledge
- **Generation**: Predict most likely next words based on context

### How ChatGPT Works (Simplified):
1. **Input**: User types a question
2. **Processing**: Model analyzes patterns from training
3. **Prediction**: Generates most probable response
4. **Output**: Returns human-like answer

### AI Limitations:
- Can generate incorrect information confidently
- No real understanding, just pattern matching
- Training data has a cutoff date
- Can perpetuate biases from training data

---

## 11. Scratch Programming üê±

### What is Scratch?
- **Visual programming language** developed by MIT
- **Drag-and-drop** interface - no typing code
- **Block-based**: Instructions are puzzle pieces that snap together
- **Purpose**: Learn programming concepts without syntax complexity

### Key Scratch Concepts:

#### Sprites and Stage
- **Sprite**: Character or object that can be programmed
- **Stage**: Background where sprites perform
- **Costumes**: Different looks for sprites
- **Backdrops**: Different backgrounds for stage

#### Programming Blocks Categories:
1. **Motion**: Move sprites around (`move 10 steps`, `turn 15 degrees`)
2. **Looks**: Change appearance (`say "Hello"`, `change color`)  
3. **Sound**: Play audio (`play sound`, `change volume`)
4. **Events**: Trigger scripts (`when green flag clicked`)
5. **Control**: Program flow (`forever`, `if then`, `repeat 10`)
6. **Sensing**: Detect conditions (`touching mouse?`, `key space pressed?`)
7. **Operators**: Math and logic (`+`, `-`, `and`, `or`)
8. **Variables**: Store data (`set score to 0`, `change score by 1`)

#### Essential Programming Concepts in Scratch:
- **Sequence**: Blocks execute in order (top to bottom)
- **Selection**: `if then else` blocks for decisions
- **Iteration**: `repeat` and `forever` blocks for loops
- **Variables**: Store and change values
- **Events**: Respond to user input or conditions

### Sample Scratch Project Structure:
```
When Green Flag Clicked
‚îú‚îÄ‚îÄ Set initial values (score = 0, lives = 3)
‚îú‚îÄ‚îÄ Forever loop:
‚îÇ   ‚îú‚îÄ‚îÄ Move sprite
‚îÇ   ‚îú‚îÄ‚îÄ Check for collisions
‚îÇ   ‚îú‚îÄ‚îÄ Update score
‚îÇ   ‚îî‚îÄ‚îÄ Check win/lose conditions
‚îî‚îÄ‚îÄ End game actions
```

---

## 12. Learning Mindset: "Explain to Solve" üßó‚Äç‚ôÇÔ∏è

### The Learning Philosophy
**"If you can't explain it simply, you don't understand it well enough"** - Einstein

### Active Learning Strategies:
1. **Teach Back**: Explain concepts to someone else
2. **Write It Out**: Create your own notes and examples
3. **Practice Problems**: Apply concepts to new situations
4. **Ask "Why?"**: Don't just memorize - understand the reasoning
5. **Connect Ideas**: Link new concepts to what you already know

### Problem-Solving Approach:
1. **Understand**: What exactly is the problem asking?
2. **Plan**: What steps will lead to the solution?
3. **Code**: Implement your plan in Scratch (or pseudocode)
4. **Test**: Does it work with different inputs?
5. **Debug**: Fix any issues you find
6. **Reflect**: What did you learn? How could you improve?

### Growth Mindset for CS:
- **Mistakes are learning opportunities**, not failures
- **Debugging is detective work** - systematic and logical
- **Start simple, then add complexity**
- **Break big problems into smaller pieces**
- **Practice consistently** rather than cramming

---

## üéØ Key Takeaways for CS50x Success:

1. **Computer Science is problem-solving** - focus on the thinking process
2. **Everything is represented as numbers** - text, images, sound, video
3. **Algorithms are step-by-step solutions** - practice breaking down problems
4. **Start with pseudocode** before jumping into any programming language
5. **Scratch teaches real programming concepts** without syntax complexity
6. **Explain concepts to others** to solidify your understanding

---

## üìö Next Steps:
- Complete the Scratch problem set
- Practice binary/decimal conversions
- Explore Scratch projects for inspiration  
- Start thinking computationally about everyday problems

Remember: **The goal isn't to memorize everything, but to understand how to think like a computer scientist!**