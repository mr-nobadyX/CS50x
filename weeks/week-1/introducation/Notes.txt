# CS50x Lecture 0: Scratch - Complete Study Notes

## 🎯 Overview
This lecture introduces computer science fundamentals through problem-solving, representation systems, and visual programming with Scratch.

---

## 1. What is Computer Science? 🧠

### Core Definition
**Computer Science** = The art of solving problems **computationally**

### Key Components:
- **Input**: The problem/data you start with
- **Algorithm**: Step-by-step instructions to solve the problem  
- **Output**: The solution/result

### Real-World Example:
Finding someone in a phone book:
- **Input**: Phone book + person's name
- **Algorithm**: 
  1. Open to middle page
  2. If name is on this page → Done!
  3. If name comes before this page → Search left half
  4. If name comes after this page → Search right half
  5. Repeat until found
- **Output**: Person's phone number

### Why This Matters:
Problem-solving skills transfer everywhere - cooking, planning trips, organizing data, building apps.

---

## 2. Number Systems 🔢

### Unary System (Base 1)
- **How it works**: Count by adding one mark each time
- **Example**: |||| represents 4
- **Problem**: Extremely inefficient for large numbers

### Decimal System (Base 10) 
- **How it works**: Uses digits 0-9
- **Place values**: Each position represents powers of 10
- **Example**: 123 = (1×10²) + (2×10¹) + (3×10⁰)

### Binary System (Base 2)
- **How it works**: Uses only 0 and 1
- **Place values**: Each position represents powers of 2
- **Example**: 101₂ = (1×2²) + (0×2¹) + (1×2⁰) = 4 + 0 + 1 = 5₁₀

### Binary Counting Table:
| Decimal | Binary | Calculation |
|---------|--------|-------------|
| 0 | 000 | 0×4 + 0×2 + 0×1 |
| 1 | 001 | 0×4 + 0×2 + 1×1 |
| 2 | 010 | 0×4 + 1×2 + 0×1 |
| 3 | 011 | 0×4 + 1×2 + 1×1 |
| 4 | 100 | 1×4 + 0×2 + 0×1 |
| 5 | 101 | 1×4 + 0×2 + 1×1 |
| 6 | 110 | 1×4 + 1×2 + 0×1 |
| 7 | 111 | 1×4 + 1×2 + 1×1 |

---

## 3. Bits and Bytes 💾

### Bits
- **Definition**: Smallest unit of information in computing
- **Values**: 0 or 1 (off or on)
- **Physical representation**: Transistors in computer chips

### Bytes
- **Definition**: 8 bits grouped together
- **Storage capacity**: Can represent 2⁸ = 256 different values (0-255)
- **Why 8 bits?**: Standardized size that can represent all ASCII characters

### Storage Hierarchy:
- 1 Bit = 0 or 1
- 1 Byte = 8 bits
- 1 Kilobyte (KB) = 1,024 bytes
- 1 Megabyte (MB) = 1,024 KB
- 1 Gigabyte (GB) = 1,024 MB
- 1 Terabyte (TB) = 1,024 GB

---

## 4. Decimal to Binary Conversion 🔄

### Method 1: Division by 2
**Steps**:
1. Divide number by 2
2. Write down remainder (0 or 1)
3. Use quotient for next division
4. Repeat until quotient is 0
5. Read remainders from bottom to top

**Example**: Convert 13 to binary
- 13 ÷ 2 = 6 remainder 1
- 6 ÷ 2 = 3 remainder 0  
- 3 ÷ 2 = 1 remainder 1
- 1 ÷ 2 = 0 remainder 1
- **Result**: 1101₂

### Method 2: Powers of 2
**Steps**:
1. Find largest power of 2 ≤ your number
2. Subtract it, place 1 in that position
3. Repeat with remainder
4. Fill empty positions with 0

**Example**: Convert 13 to binary
- 13 - 8(2³) = 5 → place 1 in 2³ position
- 5 - 4(2²) = 1 → place 1 in 2² position  
- 1 - 1(2⁰) = 0 → place 1 in 2⁰ position
- **Result**: 1101₂ (positions: 2³ 2² 2¹ 2⁰)

---

## 5. Text Representation: ASCII & Unicode 📝

### ASCII (American Standard Code for Information Interchange)
- **Purpose**: Standard way to represent text characters as numbers
- **Range**: 0-127 (fits in 7 bits, stored in 8 bits)
- **Coverage**: English letters, numbers, punctuation, control characters

### Key ASCII Values:
| Character | ASCII Value | Binary |
|-----------|-------------|---------|
| A | 65 | 1000001 |
| B | 66 | 1000010 |
| a | 97 | 1100001 |
| 0 | 48 | 0110000 |
| Space | 32 | 0100000 |

### ASCII Pattern Recognition:
- **Capital letters**: A(65) to Z(90)
- **Lowercase letters**: a(97) to z(122)  
- **Digits**: 0(48) to 9(57)
- **Difference**: Lowercase = Uppercase + 32

### Unicode
- **Purpose**: Represent ALL world languages and symbols
- **Range**: Over 1 million possible characters
- **Encoding**: UTF-8, UTF-16, UTF-32
- **Backward compatibility**: First 128 characters match ASCII exactly

---

## 6. Emojis and Colors 🎨

### Emojis
- **Technical representation**: Unicode characters
- **Example**: 😀 = U+1F600 (Unicode code point)
- **Skin tone modifiers**: Additional Unicode characters
- **Platform differences**: Each OS renders emojis differently

### Color Representation: RGB
- **RGB Model**: Red, Green, Blue components
- **Range**: Each component from 0-255 (8 bits each)
- **Total colors**: 256³ = 16,777,216 possible colors
- **Storage**: 24 bits (3 bytes) per pixel

### RGB Examples:
| Color | Red | Green | Blue | Hex Code |
|-------|-----|-------|------|----------|
| Black | 0 | 0 | 0 | #000000 |
| White | 255 | 255 | 255 | #FFFFFF |
| Red | 255 | 0 | 0 | #FF0000 |
| Green | 0 | 255 | 0 | #00FF00 |
| Blue | 0 | 0 | 255 | #0000FF |

---

## 7. Sound and Video Representation 🎵🎬

### Digital Sound
- **Analog to Digital**: Sample sound waves at regular intervals
- **Sample Rate**: How often we measure (e.g., 44,100 Hz for CDs)
- **Bit Depth**: How precisely we measure each sample
- **File Size**: Sample Rate × Bit Depth × Time × Channels

### Digital Video
- **Concept**: Series of still images (frames) shown rapidly
- **Frame Rate**: Frames per second (FPS) - usually 24, 30, or 60
- **Resolution**: Width × Height in pixels
- **File Size**: Frame Rate × Resolution × Color Depth × Time

---

## 8. Algorithms 📋

### Definition
**Algorithm**: Step-by-step instructions to solve a problem

### Essential Properties:
1. **Input**: What goes in
2. **Output**: What comes out  
3. **Definiteness**: Each step clearly defined
4. **Finiteness**: Must eventually terminate
5. **Effectiveness**: Each step must be doable

### Algorithm Efficiency
Measured by how performance changes as input size grows:

| Algorithm | Time Complexity | Example |
|-----------|-----------------|---------|
| Linear Search | O(n) | Check each item one by one |
| Binary Search | O(log n) | Divide and conquer approach |
| Selection Sort | O(n²) | Find minimum, swap, repeat |

### Real Algorithm Example: Making Tea
1. **Input**: Tea bag, hot water, cup, sugar (optional)
2. **Steps**:
   - Put tea bag in cup
   - Pour hot water over tea bag
   - Wait 3-5 minutes
   - Remove tea bag
   - Add sugar if desired
   - Stir
3. **Output**: Cup of tea

---

## 9. Pseudocode 📝

### Purpose
Write algorithms in structured English before coding

### Benefits:
- Focus on logic, not syntax
- Language-independent  
- Easy to understand and modify
- Bridge between problem and code

### Pseudocode Example: Find Maximum Number
```
INPUT: list of numbers
SET max = first number in list
FOR each remaining number in list:
    IF current number > max:
        SET max = current number
OUTPUT: max
```

### Common Pseudocode Elements:
- **Variables**: `SET variable = value`
- **Input/Output**: `INPUT user_name` / `OUTPUT result`
- **Conditions**: `IF condition THEN ... ELSE ...`
- **Loops**: `WHILE condition` / `FOR each item`
- **Functions**: `FUNCTION name(parameters)`

---

## 10. Artificial Intelligence & ChatGPTs 🤖

### What is AI?
- **Broad Definition**: Machines performing tasks that typically require human intelligence
- **Current AI**: Pattern recognition and response generation based on training data

### Large Language Models (LLMs)
- **Training**: Fed massive amounts of text from the internet
- **Learning**: Identify patterns in language and knowledge
- **Generation**: Predict most likely next words based on context

### How ChatGPT Works (Simplified):
1. **Input**: User types a question
2. **Processing**: Model analyzes patterns from training
3. **Prediction**: Generates most probable response
4. **Output**: Returns human-like answer

### AI Limitations:
- Can generate incorrect information confidently
- No real understanding, just pattern matching
- Training data has a cutoff date
- Can perpetuate biases from training data

---

## 11. Scratch Programming 🐱

### What is Scratch?
- **Visual programming language** developed by MIT
- **Drag-and-drop** interface - no typing code
- **Block-based**: Instructions are puzzle pieces that snap together
- **Purpose**: Learn programming concepts without syntax complexity

### Key Scratch Concepts:

#### Sprites and Stage
- **Sprite**: Character or object that can be programmed
- **Stage**: Background where sprites perform
- **Costumes**: Different looks for sprites
- **Backdrops**: Different backgrounds for stage

#### Programming Blocks Categories:
1. **Motion**: Move sprites around (`move 10 steps`, `turn 15 degrees`)
2. **Looks**: Change appearance (`say "Hello"`, `change color`)  
3. **Sound**: Play audio (`play sound`, `change volume`)
4. **Events**: Trigger scripts (`when green flag clicked`)
5. **Control**: Program flow (`forever`, `if then`, `repeat 10`)
6. **Sensing**: Detect conditions (`touching mouse?`, `key space pressed?`)
7. **Operators**: Math and logic (`+`, `-`, `and`, `or`)
8. **Variables**: Store data (`set score to 0`, `change score by 1`)

#### Essential Programming Concepts in Scratch:
- **Sequence**: Blocks execute in order (top to bottom)
- **Selection**: `if then else` blocks for decisions
- **Iteration**: `repeat` and `forever` blocks for loops
- **Variables**: Store and change values
- **Events**: Respond to user input or conditions

### Sample Scratch Project Structure:
```
When Green Flag Clicked
├── Set initial values (score = 0, lives = 3)
├── Forever loop:
│   ├── Move sprite
│   ├── Check for collisions
│   ├── Update score
│   └── Check win/lose conditions
└── End game actions
```

---

## 12. Learning Mindset: "Explain to Solve" 🧗‍♂️

### The Learning Philosophy
**"If you can't explain it simply, you don't understand it well enough"** - Einstein

### Active Learning Strategies:
1. **Teach Back**: Explain concepts to someone else
2. **Write It Out**: Create your own notes and examples
3. **Practice Problems**: Apply concepts to new situations
4. **Ask "Why?"**: Don't just memorize - understand the reasoning
5. **Connect Ideas**: Link new concepts to what you already know

### Problem-Solving Approach:
1. **Understand**: What exactly is the problem asking?
2. **Plan**: What steps will lead to the solution?
3. **Code**: Implement your plan in Scratch (or pseudocode)
4. **Test**: Does it work with different inputs?
5. **Debug**: Fix any issues you find
6. **Reflect**: What did you learn? How could you improve?

### Growth Mindset for CS:
- **Mistakes are learning opportunities**, not failures
- **Debugging is detective work** - systematic and logical
- **Start simple, then add complexity**
- **Break big problems into smaller pieces**
- **Practice consistently** rather than cramming

---

## 🎯 Key Takeaways for CS50x Success:

1. **Computer Science is problem-solving** - focus on the thinking process
2. **Everything is represented as numbers** - text, images, sound, video
3. **Algorithms are step-by-step solutions** - practice breaking down problems
4. **Start with pseudocode** before jumping into any programming language
5. **Scratch teaches real programming concepts** without syntax complexity
6. **Explain concepts to others** to solidify your understanding

---

## 📚 Next Steps:
- Complete the Scratch problem set
- Practice binary/decimal conversions
- Explore Scratch projects for inspiration  
- Start thinking computationally about everyday problems

Remember: **The goal isn't to memorize everything, but to understand how to think like a computer scientist!**